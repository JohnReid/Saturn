---
title: "Simple prediction script"
author: John Reid
output: html_document
---

```{r renderMe, eval = FALSE, echo = FALSE}
#
# Execute this block to render this document.
#
devtools::load_all()
rmarkdown::render("predict.Rmd")
```

Which TF will we predict on?
```{r}
tf <- 'ATF3'
```

Which cell types will we train and validate on?
```{r cellTypes}
cell.train <- c('HepG2', 'K562', 'H1-hESC')
cell.valid <- c('HCT116')
cell.all <- c(cell.train, cell.valid)
```

Choose training and validation chromosomes.
```{r chooseValidation}
chrs.train <- str_c('chr', c(3:6, 9:19, 22))
chrs.valid <- c('chr2', 'chr7', 'chr20')
```


# Responses

Load the binding data and melt to long format
```{r loadBinding}
chip <- read.chip.labels(tf)
binding.m <- do.call(c, lapply(colnames(chip)[3:ncol(chip)], function(col) chip[[col]]))
cells.m <- do.call(
  c,
  lapply(colnames(chip)[3:ncol(chip)],
         function(col) Rle(factor(col, levels = cell.levels), nrow(chip))))
chip.df <- DataFrame(
  cell = cells.m,
  chrom = rep(chip$chrom, ncol(chip) - 2),
  start = rep(chip$start, ncol(chip) - 2),
  bound = binding.m)
object.size(chip.df)
```


# Features

Load DNase features and determine which are non-zero
```{r loadFeatures}
dnase <-
  lapply(
    cell.all,
    function(cell) readRDS(file.path(
      saturn.data(), 'Features', 'DNase',
      str_c('dnase-summary-', cell, '.rds'))))
names(dnase) <- cell.all
non.zero <- lapply(dnase, function(x) x != 0)
names(non.zero) <- cell.all
num.non.zero <- Reduce('+', lapply(non.zero, sum), 0)
```
We have `r num.non.zero` DNase regions in total across training and validation.

Create data from the features and response, ignoring those regions without any DNase hits
and those that are not in our training or validation sets.
```{r mapFeatures}
train.idxs <- regions.test$chrom %in% chrs.train
valid.idxs <- regions.test$chrom %in% chrs.valid
regions.for.cell <- function(cell) {
    if (cell %in% cell.train) {
        train.idxs
    } else {
        stopifnot(cell %in% cell.valid)
        valid.idxs
    }
}
cell.data <- function(cell) {
    # Work out which regions to keep
    keep <- non.zero[[cell]] & regions.for.cell(cell)
    # Return S4Vectors::DataFrame
    DataFrame(
        cell  = Rle(factor(cell, levels = cell.levels)),
        chrom = Rle(regions.test$chrom[keep]),
        start = regions.test$start[as.vector(keep)],
        dnase = Rle(dnase[[cell]][keep]))
}
df <- Reduce(rbind, lapply(names(dnase), cell.data))
sapply(df, class)
object.size(df)
```

Join the data with the binding data
```{r joinBinding}
system.time(dt <- setkey(as.data.table(df), cell, chrom, start)[setkey(as.data.table(chip.df), cell, chrom, start), nomatch=0])
```

Match features to regions and split training from validation (ignoring ambiguous training regions)
```{r matchFeatures}
subset(dt, cell %in% cell.train, chrom %in% chrs.train, 2 != bound)
dt.train <- dt %>%
    filter(cell %in% cell.train, chrom %in% chrs.train, 'A' != bound) %>%
    mutate(bound = factor(ifelse('U' == bound, 'U', 'B'), levels=c('U', 'B')))
dt.valid <- dt %>%
    filter(cell %in% cell.valid, chrom %in% chrs.valid, 'A' != bound) %>%
    mutate(bound = factor(ifelse('U' == bound, 'U', 'B'), levels=c('U', 'B')))
```
Have `r nrow(dt.train)` training regions and `r nrow(dt.valid)`
validation regions.


# Fit

Fit a logistic regression
```{r fitLR}
contrasts(dt.train$bound)
fit <- glm(bound ~ dnase, family = binomial(link = 'logit'), data = dt.train)
summary(fit)
```


# Validate

Make predictions on validation data
```{r predict}
predictions <- predict(fit, dt.valid)
aggregate(predictions, dt.valid$bound, mean)
aggregate(predictions, dt.valid$bound, sd)
qplot(predictions)
sd(predictions['U' == dt.valid$bound])
sd(predictions['B' == dt.valid$bound])
```

Assess quality of predictions
```{r assess}
labels <- ifelse(dt.valid$bound == 'B', 1, 0)
length(labels)
length(predictions)
prg_curve = create_prg_curve(labels, predictions)
auprg = calc_auprg(prg_curve)
convex_hull = prg_convex_hull(prg_curve)
fig = plot_prg(prg_curve)
# print(prg_curve)
print(auprg)
print(convex_hull)
print(fig)
```


# Session information

```{r sessionInfo}
date()
devtools::session_info()
```
