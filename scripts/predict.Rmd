---
title: "Simple prediction script"
author: John Reid
output: html_document
---

```{r renderMe, eval = FALSE, echo = FALSE}
#
# Execute this block to render this document.
#
devtools::load_all()
rmarkdown::render("predict.Rmd")
```

Which TF will we predict on?
```{r}
tf <- 'ATF3'
```

Which cell types will we train and validate on?
```{r cellTypes}
cell.train <- c('HepG2', 'K562', 'H1-hESC')
cell.valid <- c('HCT116')
cell.all <- c(cell.train, cell.valid)
```

Choose training and validation chromosomes.
```{r chooseValidation}
chrs.train <- stringr::str_c('chr', c(3:6, 9:19, 22))
chrs.valid <- c('chr2', 'chr7', 'chr20')
```


# Responses

Load the binding data
```{r loadBinding}
chip <- read.chip.labels(tf)
```


# Features

## DNase

Load DNase features and determine which are non-zero
```{r loadFeatures}
dnase <-
  lapply(
    cell.all,
    function(cell) readRDS(file.path(
      saturn.data(), 'Features', 'DNase',
      stringr::str_c('dnase-summary-', cell, '.rds'))))
names(dnase) <- cell.all
non.zero <- lapply(dnase, function(x) x != 0)
names(non.zero) <- cell.all
num.non.zero <- Reduce('+', lapply(non.zero, sum), 0)
```
We have `r num.non.zero` DNase regions in total across training and validation.


## Motif features

Load motif features for regions with non-zero DNase
```{r loadMotifFeatures}
motif.feature.dir <- file.path(saturn.data(), 'Features', 'Motifs', 'Known')
motifs.meta <- readRDS(file.path(motif.feature.dir, 'motif-names.rds'))
#
# Load Rle motif scores for each motif
motif.features <- lapply(
  1:nrow(motifs.meta),
  function(i) readRDS(motifs.meta$feature.file[i]))
names(motif.features) <- motifs.meta$motif
filter.motif.features <- function(keep) {
  motif.keep <- lapply(motif.features, function(f) f[keep])
  names(motif.keep) <- names(motif.features)
  do.call(S4Vectors::DataFrame, motif.keep)
}
```


# Wrangle

Create data from the features and response, ignoring those regions without any DNase hits
and those that are not in our training or validation sets.
```{r mapFeatures}
train.idxs <- regions.test$chrom %in% chrs.train
valid.idxs <- regions.test$chrom %in% chrs.valid
regions.for.cell <- function(cell) {
    if (cell %in% cell.train) {
        train.idxs
    } else {
        stopifnot(cell %in% cell.valid)
        valid.idxs
    }
}
cell.data <- function(cell) {
    message('Wrangling data for: ', cell)
    # Work out which regions to keep
    keep <- non.zero[[cell]] & regions.for.cell(cell)
    # Return S4Vectors::DataFrame
    cbind(
      S4Vectors::DataFrame(
        cell  = Rle(factor(cell, levels = cell.levels)),
        chrom = Rle(regions.test$chrom[keep]),
        start = regions.test$start[as.vector(keep)],
        dnase = Rle(dnase[[cell]][keep]),
        bound = chip[[cell]][keep[regions.train$test.idx]]),
      filter.motif.features(keep))
}
df <- Reduce(rbind, lapply(names(dnase), cell.data))
sapply(df, class)
object.size(df)
```


# Training/validation split

Match features to regions and split training from validation (ignoring ambiguous training regions)
```{r matchFeatures}
df.train <- df[df$cell %in% cell.train & df$chrom %in% chrs.train & 'A' != df$bound,]
df.train$bound <- Rle(ifelse('U' == df.train$bound, 0, 1))
df.valid <- df[df$cell %in% cell.valid & df$chrom %in% chrs.valid & 'A' != df$bound,]
df.valid$bound <- Rle(ifelse('U' == df.valid$bound, 0, 1))
```
Have `r nrow(df.train)` training regions and `r nrow(df.valid)`
validation regions.


# Fit

Convert the Rle DataFrames to sparse matrices
```{r sparse}
mat.train <- as(subset(df.train, select = -c(cell, chrom, start, bound)), "Matrix")
mat.valid <- as(subset(df.valid, select = -c(cell, chrom, start, bound)), "Matrix")
```

Fit a logistic regression
```{r fitLR}
glmnet.y <- factor(ifelse(df.train$bound, 'B', 'U'), levels=c('U', 'B'))
system.time(cvfit <- glmnet::cv.glmnet(mat.train, glmnet.y, family = 'binomial'))
summary(cvfit)
plot(cvfit)
cvfit$lambda.min
coef(cvfit, s = "lambda.min")
coef(cvfit, s = "lambda.1se")
```


# Validate

Make predictions on validation data
```{r predict}
predictions <- predict(cvfit, mat.valid, s = "lambda.min")
predictions <- predict(cvfit, mat.valid, s = "lambda.1se")
dim(predictions)
```

Assess quality of predictions
```{r assess}
labels <- as.vector(df.valid$bound)
scores <- predictions[,1]
length(labels)
length(scores)
prg_curve = prg::create_prg_curve(labels, scores)
auprg = prg::calc_auprg(prg_curve)
convex_hull = prg::prg_convex_hull(prg_curve)
fig = prg::plot_prg(prg_curve)
# print(prg_curve)
print(auprg)
print(convex_hull)
print(fig)
```


# Session information

`r date()`
```{r sessionInfo}
devtools::session_info()
```

Largest objects in memory
```{r largestObjects}
largest.objects()
```
